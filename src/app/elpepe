Clon completo de player YT Music + ThemeService + SCSS modular

Quiero que crees un proyecto/feature completo que implemente un clon del reproductor de YouTube Music con UI propia y theming dinámico. Debe usar la YouTube IFrame Player API para reproducción, la YouTube Data API para metadata (opcional backend) y FastAverageColor + color para extraer y aplicar colores dominantes a la UI mediante variables CSS. El CSS ya está pensado en SCSS modular y debe integrarse. Producción en TypeScript (Angular 19+ friendly) y con buenas prácticas de tipado y extensibilidad.

Requisitos funcionales (alto nivel)

Player core

Implementar un PlayerService (Angular @Injectable({providedIn:'root'})) que:

Inicialice y gestione un YT.Player (IFrame API).

Exponga métodos: init(videoId | options), play(), pause(), seek(seconds), getCurrentTime(), getDuration(), setVolume(value), isPlaying().

Exponga eventos observables (RxJS) o EventEmitter para estado, timeupdate y cambios de video.

Maneje polling/updates seguros (ej: setInterval a 250-1000ms) y limpie timers al destruirse.

ThemeService

@Injectable({providedIn:'root'}) que:

Use FastAverageColor para extraer color de la thumbnail (o de la URL de la imagen).

Use color (tipado correcto, @types/color) para manipular: darken(), luminosity() y obtener RGB/hex.

Genere --ytmusic-album-color, --ytmusic-album-color-dark, --ytmusic-album-color-ratio en :root con document.documentElement.style.setProperty.

Expose métodos: extractFromThumbnail(url), setRatio(ratio), setConfig(partial), updateColor(alpha?).

Soporte hook/extensión para obtener alpha desde otro servicio (p. ej. transparent-player).

Tenga manejo de errores robusto y logueo claro.

SCSS modular

Entregar scss/ con parciales:

_mixins.scss, _media-queries.scss, _transitions.scss, _colors.scss, _layout.scss, _overrides.scss.

styles.scss (global) que importe parciales y consuma las variables dinámicas (--ytmusic-album-color, --ytmusic-album-color-dark, --ytmusic-background, --ytmusic-album-color-ratio).

Usar @each, @mixin, mapas y funciones SCSS para reducir repetición.

No eliminar la necesidad del runtime (JS seguirá inyectando vars).

Componente UI mínimo (Angular)

PlayerComponent con:

Carátula, título/autor (obtenidos desde YouTube Data API or playerResponse).

Barra de reproducción (seek), play/pause, prev/next (cola local), volume, mute.

Indicador de time (elapsed / total).

Visual aplicado con variables CSS dinámicas (ThemeService).

El <div id="yt-player"></div> donde el IFrame se monta pero puede estar oculto (height:0 / width:0).

Integración YouTube Data API

Ejemplo de helper para obtener metadata (title, thumbnails) desde backend (Node/Express) o directamente (advertencia sobre exponer API key).

Mostrar cómo usar respuesta para extractFromThumbnail.

TipoScript & Tipado

Añadir declare global para eventos personalizados si es necesario (p. ej. videodatachange) y/o castear donde convenga.

Corregir imports y tipos de color (npm i color @types/color).

Evitar errores de addEventListener con CustomEvent (extender DocumentEventMap o castear).

Restricciones importantes (no negociar)

No romper la dinámica runtime: SCSS solo organiza; las variables dinámicas deben ser inyectadas en runtime por ThemeService o PlayerService.

No scraping masivo ni técnicas prohibidas: IFrame API + Data API es la fuente primaria. Cualquier scraping/DOM-only es opcional y documentado como frágil.

Compatibilidad de navegadores modernos (es para Electron/Chromium o navegador moderno).

Buen tipado: no usar any salvo en casos justificados con comentario explicativo.

Entradas que ya tenés (útiles para el codificador)

Código base del plugin album-color-theme (index.ts que me diste) — usar como referencia para la extracción y mezcla de color.

SCSS global y parciales ya diseñados (tu styles.scss + _transitions.scss, _colors.scss, _layout.scss, _overrides.scss).

Tu ThemeService refactor (el que ya escribiste) — usarlo como base pero arreglar imports/types y listener typing.

Decisión: usamos IFrame API (no scrappear internals).

Entregables (archivos concretos)

src/app/services/player.service.ts — PlayerService completo (IFrame API wrapper + Observables).

src/app/services/theme.service.ts — ThemeService corregido y tipado. (ESTA HECHO JEJEJE)

src/app/components/player/player.component.ts + .html + .scss — UI mínima funcional. (CON VERSIÓN RESPONSIVE)

scss/ parciales y styles.scss integrados (compilables con sass/Angular CLI).

tests/ — unit tests (ThemeService, PlayerService).

tsconfig / package.json scripts: start, build, test, lint.

Criterios de Aceptación (QA)

Al ejecutar ng serve (o npm run start), el PlayerComponent:

Inicializa el IFrame Player (visible en DOM) y reproduce un videoId de prueba al presionar play.

La barra de progreso avanza conforme getCurrentTime() y el seek funciona.

ThemeService.extractFromThumbnail(thumbnailUrl) actualiza --ytmusic-album-color y --ytmusic-album-color-dark en :root y la UI refleja el cambio (fondo/gradientes). (TODO ESTO YA LO TENEMOS)

Tests unitarios pasan (coverage mínima en servicios).

Código documentado y modular (parciales SCSS + servicios separados).

Detalles técnicos y snippets a incluir en la entrega

PlayerService debe exponer un state$ (BehaviorSubject) con { playing, currentTime, duration, videoId }.

ThemeService: detalle de getMixedColor(color, key, alpha, ratioMultiply) con color-mix CSS string (igual que tu versión).

Tipado: declare global { interface DocumentEventMap { videodatachange: CustomEvent<...> } } ejemplo.

Remoción de listeners: cuando añadas eventos con document.addEventListener, guardar handler en variable y usar removeEventListener con la misma referencia en ngOnDestroy()/destroy().

Tareas paso a paso (para quien implemente)

Crear PlayerService con wrapper IFrame API y tests.

Crear ThemeService a partir de tu refactor, corregir imports/tipos y el addEventListener de videodatachange con tipado seguro.

Integrar ThemeService en PlayerComponent: cuando state$.videoId cambie, obtener thumbnail via Data API -> theme.extractFromThumbnail(thumbnailUrl). (esto ya lo tenemos, te lo dejo de referencia nomas)

Mover CSS a scss/ parciales y compilar (chequear variables dinámicas aplicadas).

Revisar y documentar puntos donde se podría enchufar transparent-player u otros hooks externos.

Mensaje final para ti, mi Groksito:

"Generá el código completo según los requisitos arriba. Comentá y explica las decisiones relevantes (tipado, manejo de eventos). Si algo no se puede implementar textualmente (ej. credenciales de la API), indicá claramente lo que falta y dejá un mock/placeholder."